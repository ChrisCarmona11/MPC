/*
 * main.c
 *
 *  Created on: Feb 27, 2024
 *      Author: chris
 */
/*
 * main implementation: use this 'C' sample to create your own application
 *
 */

#include "derivative.h" /* include peripheral declarations */
#include <constantes_int_1.h>

//valores para contadores
static int contador_ms;
#define LDVAL_TRIGGER_1MS 20640 // 1ms/48.45ns = 20639.83
//Registro donde guardar los contadores de ms
#define RegistroSize 4
static int registro[RegistroSize];

static int indexer;			// Variable para ir atravesando el registro

static float scala =  10.0/65535.0;

static int registro[128][4];

extern void enable_irq(int irq); // Función para habilitar los registros de interrupción

void lptmr_clear_registers() {
	LPTMR0_CSR = 0x00;
	LPTMR0_PSR = 0x00;
	LPTMR0_CMR = 0x00;
}

void pit_interrupt_config(void)
/*
 * Contador para detectar la interrupción de milisegundo mediante un preescaler
 * */
{
	// Enable the clock to the PIT module
	SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
	// Enable PIT module control register
	PIT_MCR = PIT_MCR_FRZ_MASK;
	// Disable timer and interrupt
	PIT_TCTRL0 = 0;
	// Load value (Timer Load Value Register (PIT_LDVALn))
	PIT_LDVAL0 = LDVAL_TRIGGER_1MS; // Trigger 1 ms
	// Clear any pending interrupt
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK;
	// Enable interrupt
	enable_irq(68); // Registro 2 y 4 de sobra asi que el bit flag será el 4 creo.
	// Enable timer and interrupt
	PIT_TCTRL0 = (PIT_TCTRL_TIE_MASK | PIT_TCTRL_TEN_MASK);
}

float toVolts (int number){
	float valor = number*scala;
	return valor;
}

void pit0_isr(void) {
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK; //Clear LPT Compare flag
	indexer = 0;
	ch_buf_1[contador_ms] = tabla[contador_ms][0];
	ch_buf_2[contador_ms] = tabla[contador_ms][1];
	ch_buf_3[contador_ms] = tabla[contador_ms][2];
	ch_buf_4[contador_ms] = tabla[contador_ms][3];
	contador_ms++; //Aumentar el contador de milisegundos
}

int main(void) {

	//Configuracion de los timers
	pit_interrupt_config();
	int max[4]= {0,0,0,0};
	int min[4]= {0,0,0,0};
	int accumulative[4] = {0,0,0,0};
	int j=0;
	for (;;) {
		for (;j<4;j++){
			if (channel_1[counter_ms]> max[0]) max[0]= channel_1[counter_ms];
			if (channel_1[counter_ms]< min[0]) min[0]= channel_1[counter_ms];
		}
		if (contador_ms==128) {
			memcpy( channel_1 ,ch_buf_1, sizeof(int)*128);
			memcpy( channel_2 ,ch_buf_2, sizeof(int)*128);
			memcpy( channel_3 ,ch_buf_3, sizeof(int)*128);
			memcpy( channel_4 ,ch_buf_4, sizeof(int)*128);
			
			
			
		}
	}

	return 0;
}

