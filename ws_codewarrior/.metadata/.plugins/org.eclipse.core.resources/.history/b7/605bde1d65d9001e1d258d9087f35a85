/*
 * main implementation: use this 'C' sample to create your own application
 *
 */





#include "derivative.h" /* include peripheral declarations */
#include <stdio.h>
#include <math.h>
#include <Driver_SLCD.h>
#include <PounceTypes_v2.h>
#include <Fonts_LCD.h>
//#include <kinetis.h>
//#include "stdio.h" si se pone así el compilador buscará primero en la carpeta del proyecto

/*#define CONFIGURE_SLCD()   MCG_C1 |= MCG_C1_IRCLKEN; \
						   POWER_UP(3, SIM_SCGC3_SLCD); \
						   LCD_GCR = (LCD_GCR_CPSEL | LCD_GCR_RVEN | LCD_GCR_RVTRIM_MASK | LCD_GCR_LADJ_MASK | LCD_GCR_LCLK_0 | LCD_GCR_VSUPPLY_VLL3_EXT | LCD_GCR_SOURCE | LCD_GCR_DUTY_8BP | LCD_GCR_ALTDIV_NONE); \
						   LCD_PENL = 0xfffffffe; \
						   LCD_PENH = 0x0000ffff; \
						   LCD_BPENL = 0x00000000; \
						   LCD_BPENH = 0x0000ff00; \
						   fnClearSLCD(); \
						   WRITE_SLCD(43TO40, 0x08040201); \
						   WRITE_SLCD(47TO44, 0x80402010); \
						   LCD_GCR = (LCD_GCR_LCDEN | LCD_GCR_CPSEL | LCD_GCR_RVEN | LCD_GCR_RVTRIM_MASK | LCD_GCR_LADJ_MASK | LCD_GCR_LCLK_0 | LCD_GCR_VSUPPLY_VLL3_EXT | LCD_GCR_SOURCE | LCD_GCR_DUTY_8BP | LCD_GCR_ALTDIV_NONE)*/

void fun1();
int fun2();
int fun3(int a);
int fun4(int a, int *b) {
	return a + *b;
}
int fun_suma(int a, int b) {
	return a + b;
}
// 1. EJERCICIO

/* En la seccion de las declaraciones, con las primeras tres funciones lo unico que
 * ha hecho el compilador es crear las referencias a las funciones en la parte superior
 * del archivo. Las últimas funciones en cambio si que están definidas y por ello se puede
 * ver que se reserva espacio en la pila para realizar sus operaciones en ella.
 * El primero recibe un apuntador como dato de entrada mientras que el segundo recibe el
 * valor en si. En el código de ensamblador se puede apreciar que en la funcion fun4, lo 
 * que se guarda en la pila es efectivamente la direccion y cuando va a acceder a los
 * valores de a y b para hacer al suma, toma el valor de a directamente de la pila mientras
 * que para obtener b, carga la direccióin almacenada en un registro y despues mueve carga
 * b moviendolo desde la memoria. Con la funcion fun_suma en cambio, lo que se guarda en
 * la pila son directamente a y b.
 */

// Declaraciones funciones externas
extern void lptmr_interrupt();
extern void lptmr_time_counter();
extern void time_delay(unsigned int delay);
extern void pit_interrupt_config();
extern void _SLCDModule_Init(void);
extern void _SLCDModule_PrintString(STRING SourceString, U08 StartPosition);
extern void _SLCDModule_PrintUpperArrow(void);
extern void _SLCDModule_TurnOffAllSegments(void);
extern void _SLCDModule_ClearLCD(U08 ArrowsOn);

// Variables globales externas
extern int LPTMR_INTERRUPT;
extern int PIT0_INTERRUPT;
extern unsigned int ms_contados[];

// Variables globales del main
int int_counter = 0;
int contador_ms = 0;
int contador_ms_reg = 0;

void using_default_manager() {
	
	lptmr_interrupt();
		
	/* Para que cuando salte la interrupcion se ejecute la rutina de servicio, hay que escribir
	 * la direccion de la funcion en el vector de interrupciones. En C es suficiente con poner el
	 * nombre de la funcion en la direccion correspondiente.
	 */
	
	for (;;)
	{
		/* La rutina de servicio incrementa el contador y pone a 1 la variable global LPTMR_INTERRUPT,
		 * de esta forma, aquí se detecta ese cambio y se muestra el segundo. despues de mostrarlo, se
		 * vuelve a poner a cero. El tiempo que transcurre al mostrar el valor en pantalla y para 
		 * activar y desactivar la variable global, hace que hay imprecisiones en el mostrado del segundo.
		 */
		if (LPTMR_INTERRUPT == 1) {
			printf("Tiempo transcurrido: %d\n", int_counter);
			LPTMR_INTERRUPT = 0;
		}
	}
}

void managing_manually() {
	lptmr_time_counter();
	
	/*
	 * A diferencia del anterior, este no pone TIE a 1.
	 */
	
	for (;;)
	{
		/* En este caso, se mira directamente el valor del bit TCF del CSR y en cuanto se detecta que se
		 * pone a 1 (lo que indica que ha superado el valor de comparacion), se incrementa el contador y
		 * se muestra en pantalla. Es importante remarcar que la condicion del if cpmprueba que la operacion
		 * AND bitwise entre ambos sea distinta de 0 y no 1 en concreto. El True booleano en esta operacion
		 * no sera numericamente 1.
		 */
		if ((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) !=0) {
			int_counter++;
			printf("Tiempo transcurrido: %d\n", int_counter);
			LPTMR0_CSR|=LPTMR_CSR_TCF_MASK;
		}
	}
}

void managing_waiting() {
	
	unsigned int t_d = 1;
	for (;;) {
		/* Con este metodo se llama a la funcion time_delay para hacer tiempo y cuando termina se muestra el 
		 * segundo. Ajustando un poco los valores se ha logrado un transcurso de tiempo similar al de 1s.
		 */
		time_delay(t_d);
		int_counter++;
		printf("Tiempo transcurrido: %d\n", int_counter);
	}
}

void using_default_manager_with_ms() {
	// Declaraciones de variables locales
	unsigned int i;
	
	pit_interrupt_config();
	lptmr_interrupt();
		
	/* Se añade la funcion de inicializacion del pit0.
	 */
	
	while (int_counter < 10)
	{
		/*
		 * Bucle vacio que espera unos 10 segundos
		 */
	}
	printf("Array de milisegundos\n");
	for (i = 0; i < 10; i++) {
		printf("%d\n", ms_contados[i]);
	}
}

void print_timer_val() {
	//unsigned int char_amount = 4;
	//unsigned int word_size = char_amount * CHAR_SIZE;
	//char my_word[35] = {_L};
	STRING my_str = "0000";
	int total_length = 32;
	int str_size;
	
	/*my_word[0] = &_H;
	my_word[1] = &_O;
	my_word[2] = &_L;
	my_word[3] = &_A;*/
	lptmr_interrupt();
	_SLCDModule_Init();
	//_SLCDModule_PrintUpperArrow();
	//_SLCDModule_TurnOffAllSegments();
	_SLCDModule_PrintString("1", 0); // asi puesto no lo hace
	//_SLCDModule_PrintString(my_str, 0);
//	
//	while(int_counter < 30) {
//		if (LPTMR_INTERRUPT == 1) {
//			_SLCDModule_ClearLCD(NO_ARROWS);
//			sprintf(my_str, "%d", int_counter);
//			str_size = total_length - 6 * (int)log10(int_counter);
//			_SLCDModule_PrintString(my_str, str_size);
//			LPTMR_INTERRUPT = 0;
//		}
//	}
}

int main(void)
 {
	int v1 = 0, v2 = 0, v3;
	int in1 = 0, in2 = 0;
	
	//Enable Port clocks
	SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK;
	
	/* Enable LPT Module */
	SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK;


	  
	//fun1();
	//v1 = fun2();
	//v2 = fun3(in1);
	v3 = fun4(in2, &in2);
	v3++;
	/* En la declaracion se puede ver que carga los valores en registros y despues salta
	 * a la direccion de la funcion, es decir, hace una llamada a la funcion. El v3++ se ha
	 * añadido para quitar el warning de variable no usada.
	 */
	
	// 2. EJERCICIO
	/*
	 * Hay dos formas de hacerlo, dejando que el gestor de interrupciones gestione la interrupcion
	 * o gestionando la interrupcion manualmente. Si se deja que el gestor gestione las interrupciones,
	 * estas deben estar habilitadas, mientras que si se gestionan manualmente habra que comprobar
	 * en cada iteracion cual es el valor de comparacion.
	 * 
	 * a) Usando el gestor de interrupciones
	 * Lo primero es habilitar las interrupciones. Se hace poniendo a 1 el bit TIE del CSR.
	 * La funcion lptmr_interrupt() se encarga de eso y de activar el timer para que empiece
	 * a contar. Se configura para que use el reloj LPO de 1kHz, por lo tanto, habra 1000
	 * ciclos de reloj por segundo y como el timer incrementa con cada ciclo del reloj, para
	 * contar 1s el valor de comparacion debe ser 1000.
	 */
	//using_default_manager();
	
	/*
	 * b) Gestionando la interrupcion manualmente
	 * Si no se habilitan las interrupciones, el gestor no saltara a ninguna rutina de servicio.
	 */
	//managing_manually();
	
	/*
	 * c) Usando una funcion de espera
	 * La ultima opcion es hacer una funcion que espere exactamente 1s. Esta es la opcion menos
	 * precisa ya que depende del tiempo de ejecución de varios bucles. Cosa que no siempre sera
	 * lo mismo.
	 */
	//managing_waiting();
	
	// 3. EJERCICIO
	
	/*
	 * Para programar la interrupcion de milisegundo se usa una segunda rutina de servicio que se
	 * llama desde otro vector de interrupcion. Se programa de tal forma que la interrupcion de
	 * milisegundo tenga una prioridad mayor que la de segundo. Esto se puede hacer escribiendo
	 * el valor de prioridad en el registro NVICIP correspodiente.
	 * 
	 * Otro aspecto importante es que para que los milisegundos se cuenten correctamente, es crucial
	 * que la CPU no este ocupada haciendo otras tareas no prioritarias, como por ejemplo, imprimir
	 * en pantalla la cantidad de segundos transcurridos por momento o la cantidad de milisegundos
	 * contados en el segundo anterior. despues de hacer varios tests, queda claro que si se imprime
	 * el tiempo transcurrido por momentos se van perdiendo milisegundos y va empeorando a medida
	 * que pasan los segundos.
	 * 
	 * Para guardar la cantidad de milisegundos contados en cada segundo, se usa un array. Para
	 * probar el codigo, se ha programado para que cuente 10 segundos y despues de contarlos muestre
	 * en pantalla los 10 valores almacenados. Cabe destacar que se ha tenido que ajustar el valor
	 * de comparacion del contador lejos de su valor teorico. Teniendo en cuenta que el periodo
	 * del PIT es de 48.45 ns, el valor de comparacion deberia ser 20639. Sin embargo, con ese 
	 * valor salian 995 ms por segundo, asi que se ha ajustado el valor a 20550 con el cual se 
	 * consiguen contajes de 999 o 1000 ms por segundo.
	 */
	//using_default_manager_with_ms();
	
	// 4. EJERCICIO
	
	/*
	 * Mostrar un string en pantalla se hace usando las funciones proporcionadas, concretamente, la
	 * funcion que se va a usar es _SLCDModule_PrintString, la cual recibe dos argumentos de entrada:
	 * la posición de inicio en la pantalla del string y el propio string. Esta funcion se llama desde
	 * la funcion que imprime los valores, que a su vez lee el valor del contador a través de la
	 * variable global.
	 */
	print_timer_val();
	
	return 0;
}
