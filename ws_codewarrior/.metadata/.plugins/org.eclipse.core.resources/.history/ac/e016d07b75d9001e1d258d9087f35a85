/*
 * main.c
 *
 *  Created on: Feb 27, 2024
 *      Author: chris
 */
/*
 * main implementation: use this 'C' sample to create your own application
 *
 */

#include "derivative.h" /* include peripheral declarations */
#include <constantes_int_1.h>

//valores para contadores
static int contador_ms;
#define LDVAL_TRIGGER_1MS 20640 // 1ms/48.45ns = 20639.83
//buffer2 donde guardar los contadores de ms
#define buffer2Size 4
static int buffer2[buffer2Size];

static int indexer;			// Variable para ir atravesando el buffer2

static float scala =  10.0/65535.0;

int buffer[128][4];

extern void enable_irq(int irq); // Función para habilitar los buffer2s de interrupción

void lptmr_clear_buffer2ers() {
	LPTMR0_CSR = 0x00;
	LPTMR0_PSR = 0x00;
	LPTMR0_CMR = 0x00;
}

void pit_interrupt_config(void)
/*
 * Contador para detectar la interrupción de milisegundo mediante un preescaler
 * */
{
	// Enable the clock to the PIT module
	SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
	// Enable PIT module control buffer2er
	PIT_MCR = PIT_MCR_FRZ_MASK;
	// Disable timer and interrupt
	PIT_TCTRL0 = 0;
	// Load value (Timer Load Value buffer2er (PIT_LDVALn))
	PIT_LDVAL0 = LDVAL_TRIGGER_1MS; // Trigger 1 ms
	// Clear any pending interrupt
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK;
	// Enable interrupt
	enable_irq(68); // buffer2 2 y 4 de sobra asi que el bit flag será el 4 creo.
	// Enable timer and interrupt
	PIT_TCTRL0 = (PIT_TCTRL_TIE_MASK | PIT_TCTRL_TEN_MASK);
}

float toVolts (int number){
	float valor = number*scala;
	return valor;
}

void pit0_isr(void) {
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK; //Clear LPT Compare flag
	indexer = 0;
	for (;indexer<4;indexer++){
		buffer2[contador_ms][indexer]= tabla[contador_ms][indexer];
	}
	contador_ms++; //Aumentar el contador de milisegundos
}

int main(void) {

	//Configuracion de los timers
	pit_interrupt_config();
	int max[4]= {0,0,0,0};
	int min[4]= {0,0,0,0};
	int accumulative[4] = {0,0,0,0};
	int j=0;
	for (;;) {
		for (j=0;j<4;j++){
			if (buffer[contador_ms][j]> max[j]) max[j]= buffer[contador_ms][j];
			if (buffer[contador_ms][j]< min[j]) min[j]= buffer[contador_ms][j];
			accumulative[j]+=buffer[contador_ms][j];
		}
		if (contador_ms==128) {
			
			contador_ms++;
			int k= 0
			for (;k<4;k++){
						if (buffer[contador_ms][j]> max[j]) max[j]= buffer[contador_ms][j];
						if (buffer[contador_ms][j]< min[j]) min[j]= buffer[contador_ms][j];
						accumulative[j]+=buffer[contador_ms][j];
					}	
		}
	}

	return 0;
}

