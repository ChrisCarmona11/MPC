/*
 * main.c
 *
 *  Created on: Feb 27, 2024
 *      Author: chris
 */
/*
 * main implementation: use this 'C' sample to create your own application
 *
 */

#include "derivative.h" /* include peripheral declarations */
#include <stdio.h>
#include <string.h>

#define VALOR_OBJETIVO 999

#define LDVAL_TRIGGER_1MS 20639 // 1ms/48.45ns = 20639.83
int LPTMR_INTERRUPT, int_counter, contador_ms, FLAG_MS;

extern void enable_irq(int irq);

void lptmr_clear_registers() {
	LPTMR0_CSR = 0x00;
	LPTMR0_PSR = 0x00;
	LPTMR0_CMR = 0x00;
}
void lptmr_interrupt() {
	int compare_value = 999;  //value must be less than 0xFFFF

	//Enable Port clocks
	SIM_SCGC5 |=
			SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK
					| SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK;

	/* Enable LPT Module */SIM_SCGC5 |= SIM_SCGC5_LPTIMER_MASK;

	LPTMR_INTERRUPT = 0; //Clear global variable

	//Reset LPTMR module
	lptmr_clear_registers();

	/* Enable LPT Interrupt in NVIC*/
	enable_irq(85); //LPTMR Vector is 101. IRQ# is 101-16=85

	/* Configure LPT */LPTMR0_CMR = LPTMR_CMR_COMPARE(compare_value); //Set compare value
	LPTMR0_PSR = LPTMR_PSR_PCS(0x1) | LPTMR_PSR_PBYP_MASK; //Use LPO clock and bypass prescale

	// Habilita la interrupcion del timer.
	LPTMR0_CSR = LPTMR_CSR_TIE_MASK;  //Enable LPT interrupt

	LPTMR0_CSR |= LPTMR_CSR_TEN_MASK; //Turn on LPTMR and start counting

}

void lptmr_isr(void) {
	LPTMR0_CSR |= LPTMR_CSR_TCF_MASK;  //Clear LPT Compare flag
	LPTMR_INTERRUPT = 1;  //Set global variable
	int_counter++;
}

void pit_interrupt_config(void)
/*
 * Contador para detectar la interrupción de milisegundo mediante un preescaler
 * */
{
	// Enable the clock to the PIT module
	SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
	// Enable PIT module control register
	PIT_MCR = PIT_MCR_FRZ_MASK;
	// Disable timer and interrupt
	PIT_TCTRL0 = 0;
	// Load value (Timer Load Value Register (PIT_LDVALn))
	PIT_LDVAL0 = LDVAL_TRIGGER_1MS; // Trigger 1 ms
	// Clear any pending interrupt
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK;
	// Enable interrupt
	enable_irq(68); // Registro 2 y 4 de sobra asi que el bit flag será el 4 creo.
	// Enable timer and interrupt
	PIT_TCTRL0 = (PIT_TCTRL_TIE_MASK | PIT_TCTRL_TEN_MASK);
	contador_ms = 0;
}
void pit0_isr(void) {
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK; //Clear LPT Compare flag
	// Tareas a realizer
	contador_ms++;
	if (contador_ms==1000)FLAG_MS = 1;
}

int main(void) {
	LPTMR_INTERRUPT = 0;
	contador_ms = 0;
	FLAG_MS = 0;

	int indexer = 0;
	int registro[11];

	lptmr_interrupt();
	pit_interrupt_config();

	for (;;) {
		if (LPTMR_INTERRUPT == 1) {
			LPTMR_INTERRUPT = 0;
//				printf("Time: %i \n", int_counter);
//				printf("Time_ms: %i \n", contador_ms);
			registro[indexer] = contador_ms;
			contador_ms = 0;
			indexer++;
		}
		if (indexer == 9) {
//				printf("[%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i]\n",
//						registro[0],
//						registro[1],
//						registro[2],
//						registro[3],
//						registro[4],
//						registro[5],
//						registro[6],
//						registro[7],
//						registro[8],
//						registro[9]
//						         );  
			indexer = 0;
		}
	}

	return 0;
}

