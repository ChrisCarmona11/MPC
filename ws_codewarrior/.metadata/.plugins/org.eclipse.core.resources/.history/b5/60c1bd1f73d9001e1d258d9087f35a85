/*
 * main.c
 *
 *  Created on: Feb 27, 2024
 *      Author: chris
 */
/*
 * main implementation: use this 'C' sample to create your own application
 *
 */

#include "derivative.h" /* include peripheral declarations */
#include <constantes_int_1.h>

//valores para contadores
static int contador_ms;
#define LDVAL_TRIGGER_1MS 20640 // 1ms/48.45ns = 20639.83
//Registro donde guardar los contadores de ms
#define RegistroSize 4
static int registro[RegistroSize];

static int indexer;			// Variable para ir atravesando el registro

static float scala =  10.0/65535.0;

static int buffer[128][4];
static int registro[128][4];

extern void enable_irq(int irq); // Función para habilitar los registros de interrupción

void lptmr_clear_registers() {
	LPTMR0_CSR = 0x00;
	LPTMR0_PSR = 0x00;
	LPTMR0_CMR = 0x00;
}

void pit_interrupt_config(void)
/*
 * Contador para detectar la interrupción de milisegundo mediante un preescaler
 * */
{
	// Enable the clock to the PIT module
	SIM_SCGC6 |= SIM_SCGC6_PIT_MASK;
	// Enable PIT module control register
	PIT_MCR = PIT_MCR_FRZ_MASK;
	// Disable timer and interrupt
	PIT_TCTRL0 = 0;
	// Load value (Timer Load Value Register (PIT_LDVALn))
	PIT_LDVAL0 = LDVAL_TRIGGER_1MS; // Trigger 1 ms
	// Clear any pending interrupt
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK;
	// Enable interrupt
	enable_irq(68); // Registro 2 y 4 de sobra asi que el bit flag será el 4 creo.
	// Enable timer and interrupt
	PIT_TCTRL0 = (PIT_TCTRL_TIE_MASK | PIT_TCTRL_TEN_MASK);
}

float toVolts (int number){
	float valor = number*scala;
	return valor;
}

void pit0_isr(void) {
	PIT_TFLG0 |= PIT_TFLG_TIF_MASK; //Clear LPT Compare flag
	indexer = 0;
	for (;indexer<4;indexer++){
		registro[contador_ms][indexer]= tabla[contador_ms][indexer];
	}
	contador_ms++; //Aumentar el contador de milisegundos
}

int main(void) {

	//Configuracion de los timers
	pit_interrupt_config();
	int max[4]= {0,0,0,0};
	int min[4]= {0,0,0,0};
	int accumulative[4] = {0,0,0,0};
	int j=0;
	for (;;) {
		for (j=0;j<4;j++){
			if (registro[counter_ms][j]> max[j]) max[j]= registro[counter_ms][j];
			if (registro[counter_ms][j]< min[j]) min[j]= registro[counter_ms][j];
			accumulative[j]+=registro[counter_ms][j];
		}
		if (contador_ms==128) {
			memcpy( registro,buffer, sizeof(int)*128*4);
			
			
			max[4]= {0,0,0,0};
			min[4]= {0,0,0,0};
			accumulative[4] = {0,0,0,0};
			
		}
	}

	return 0;
}

