/*
 * main implementation: use this 'C' sample to create your own application
 *
 */

#include "derivative.h" /* include peripheral declarations */
#include <stdio.h>
#include <string.h>

#define VALOR_OBJETIVO 999

#define LDVAL_TRIGGER_1MS 20639 // 1ms/48.45ns = 20639.83


int LPTMR_INTERRUPT, int_counter;

extern void enable_irq (int irq);

void lptmr_time_counter_configure();
void lptmr_time_counter_run();
void lptmr_clear_registers();
/*
 * Delay function using the LPTMR module
 */
void lptmr_time_counter_configure()
{
  int compare_value=VALOR_OBJETIVO;  //value must be less than 0xFFFF or 65535

	//Enable Port clocks
	SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK;
	
	/* Enable LPT Module */
	SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK;
	
	lptmr_clear_registers(); // Limpiar los registros del timer

	/* Configure LPTMR */
	LPTMR0_CMR=LPTMR_CMR_COMPARE(compare_value);  //Set compare value
	LPTMR0_PSR=LPTMR_PSR_PCS(0x1)|LPTMR_PSR_PBYP_MASK;  //Use LPO clock and bypass prescale

	// Habilitada el reloj 01 y hago or con PBYP para deshabilitarlo el modo bypass.

	LPTMR0_CSR|=LPTMR_CSR_TEN_MASK; //Turn on LPTMR with default settings
	//Para selccionar el bit de entrada 1 que es precisamente el reloj de 1KHz.
}
//
//void lptmr_time_counter_run(int *CNR_array, int *print_number){
//	 //Wait for Timer Compare Flag to be set
//	  if((LPTMR0_CSR & LPTMR_CSR_TCF_MASK)==0) //Si el registro CSR y el bit TCF 
//	  {
//	    //This may not get proper counter data if the CNR is read at the same time it is incremented
////		  printf("Current value of counter register CNR is %d\n",LPTMR0_CNR);
//		  CNR_array[*print_number]= LPTMR0_CNR;
//		  LPTMR0_CSR|=LPTMR_CSR_TCF_MASK; // Para limpiar el TCF del CSR.
//		  *print_number++;
//	  }
//	  *print_number=*print_number%10;
//	  
//	  if (*print_number%10 == 0) printf ("Number of ticks: %i",CNR_array[5]);
//	  
//	  printf("Current value of counter register CNR is %d\n",LPTMR0_CNR);
//}

void lptmr_clear_registers()
{
  LPTMR0_CSR=0x00;
  LPTMR0_PSR=0x00;
  LPTMR0_CMR=0x00;
}
void lptmr_interrupt()
{
  int compare_value=999;  //value must be less than 0xFFFF

  //Enable Port clocks
  SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK;

  /* Enable LPT Module */
  SIM_SCGC5|=SIM_SCGC5_LPTIMER_MASK;

  LPTMR_INTERRUPT=0; //Clear global variable

  //Reset LPTMR module
  lptmr_clear_registers();

  /* Enable LPT Interrupt in NVIC*/
  enable_irq(85); //LPTMR Vector is 101. IRQ# is 101-16=85

  /* Configure LPT */
  LPTMR0_CMR=LPTMR_CMR_COMPARE(compare_value);  //Set compare value
  LPTMR0_PSR=LPTMR_PSR_PCS(0x1)|LPTMR_PSR_PBYP_MASK;  //Use LPO clock and bypass prescale
  
  // Habilita la interrupcion del timer.
  LPTMR0_CSR=LPTMR_CSR_TIE_MASK;  //Enable LPT interrupt

  LPTMR0_CSR|=LPTMR_CSR_TEN_MASK; //Turn on LPTMR and start counting

}

void lptmr_isr(void)
{
  LPTMR0_CSR|=LPTMR_CSR_TCF_MASK;  //Clear LPT Compare flag
  LPTMR_INTERRUPT=1;  //Set global variable
  int_counter++;
//   pasa_segundo = 1;
//  printf("\n\nIn LPT ISR!\n\n");
//  printf("Veces en interrupcion %d \n", int_counter);
}



int main(void)
{
	lptmr_interrupt();
	  
	for(;;) {
		if(LPTMR_INTERRUPT == 1){
			
			LPTMR_INTERRUPT=0;
			printf("Time: %i \n", int_counter);
		}
	}
	
	return 0;
}
